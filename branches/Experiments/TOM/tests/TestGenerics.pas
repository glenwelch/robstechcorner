unit TestGenerics;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Generics.Defaults, Generics.Collections, Classes, SysUtils,
  Generics.InterfaceList, SyncObjs;

type


  // Test methods for class TThreadList
  TestTThreadList = class(TTestCase)
  strict private
    FThreadList: TThreadList<Integer>;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAdd;
    procedure TestClear;
    procedure TestRemove;
  end;
  // Test methods for class IInterfaceList
  TestIInterfaceList = class(TTestCase)
  strict private
    FIInterfaceList: IInterfaceList<IInterface>;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCapacity;
    procedure TestGetCount;
    procedure TestSetCount;
    procedure TestClear;
    procedure TestDelete;
    procedure TestExchange;
    procedure TestFirst;
    procedure TestIndexOf;
    procedure TestAdd;
    procedure TestInsert;
    procedure TestLast;
    procedure TestRemove;
    procedure TestGetEnumerator;
  end;


implementation

procedure TestTThreadList.SetUp;
begin
  FThreadList := TThreadList<Integer>.Create;
end;

procedure TestTThreadList.TearDown;
begin
  FThreadList.Free;
  FThreadList := nil;
end;

procedure TestTThreadList.TestAdd;
var
  Item: Integer;
  List : TList<Integer>;
begin
  // TODO: Setup method call parameters
  item := 1234;
  FThreadList.Add(Item);

  List := FThreadlist.LockList;
  try
  CheckEquals(List.Count,1);
  CheckEquals(List.Items[0],1234);
  finally
    FThreadList.UnLockList;
  end;
end;

procedure TestTThreadList.TestClear;
var
  List : TList<Integer>;
begin
  FThreadList.Add(1234);
  FThreadList.Add(123);
  FThreadList.Add(12);
  FThreadlist.Add(1);
  FThreadList.Clear;

  List := FThreadlist.LockList;
  try
    CheckEquals(List.Count,0);
  finally
    FThreadList.UnLockList;
  end;
end;

procedure TestTThreadList.TestRemove;
var
  List : TList<Integer>;
begin
  FThreadList.Add(1234);
  FThreadList.Add(123);
  FThreadList.Add(12);
  FThreadList.Add(1);
  FThreadList.Remove(1);
  List := FThreadlist.LockList;
  try
    CheckEquals(List.Count,3);
    CheckEquals(List.IndexOf(1),-1);
  finally
    FThreadList.UnLockList;
  end;
end;


procedure TestIInterfaceList.SetUp;
begin
  FIInterfaceList := TInterfaceList<IInterface>.Create;
end;

procedure TestIInterfaceList.TearDown;
begin
  FIInterfaceList := nil;
end;


procedure TestIInterfaceList.TestCapacity;
var
  ReturnValue: Integer;
begin
  FIInterfaceList.SetCapacity(200);
  ReturnValue := FIInterfaceList.GetCapacity;
  CheckEquals(200,ReturnValue);
end;

procedure TestIInterfaceList.TestGetCount;
var
  ReturnValue: Integer;
begin
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  ReturnValue := FIInterfaceList.GetCount;
  CheckEquals(2,ReturnValue);
end;


procedure TestIInterfaceList.TestSetCount;
var
  NewCount: Integer;
begin
  NewCount := -1;
  ExpectedException := EArgumentOutOfRangeException;
  FIInterfaceList.SetCount(NewCount);
end;

procedure TestIInterfaceList.TestClear;
begin
  FIInterfaceList.Clear;
  // TODO: Validate method results
end;

procedure TestIInterfaceList.TestDelete;
var
  I : IInterface;
  O : TInterfacedObject;
begin
  O := TInterfacedObject.Create;
  I := (O as IInterface);
  FIInterfaceList.Add(I);
  FIInterfaceList.Delete(0);
  CheckEquals(0,FIInterfaceList.Count);
  CheckEquals(1,O.RefCount);
end;

procedure TestIInterfaceList.TestExchange;
var
  Index2: Integer;
  Index1: Integer;
  I1,I2 : IInterface;
begin
  Index1 := 0;
  Index2 := 1;
  I1 := TInterfacedObject.Create;
  I2 := TInterfacedObject.Create;
  FIInterfaceList.Add(I1);
  FIInterfaceList.Add(I2);
  CheckEquals(0,FIInterfaceList.IndexOf(I1));
  CheckEquals(1,FIInterfaceList.IndexOf(I2));
  FIInterfaceList.Exchange(Index1, Index2);
  CheckEquals(2,FIInterfaceList.count);
  CheckEquals(0,FIInterfaceList.IndexOf(I2));
  CheckEquals(1,FIInterfaceList.IndexOf(I1));
end;

procedure TestIInterfaceList.TestFirst;
var
  ReturnValue: IInterface;
  I1 : IInterface;
begin
  I1 := TInterfacedObject.Create;
  FIInterfaceList.Add(I1);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  ReturnValue := FIInterfaceList.First;
  CheckSame(I1,ReturnValue);
end;

procedure TestIInterfaceList.TestIndexOf;
var
  ReturnValue: Integer;
  I1 : IInterface;
begin
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  I1 := TInterfacedObject.Create;
  FIInterfaceList.Add(I1);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  ReturnValue := FIInterfaceList.IndexOf(I1);
  CheckEquals(2,ReturnValue);
end;

procedure TestIInterfaceList.TestAdd;
var
  I : IInterface;
  O : TInterfacedObject;
begin
  O := TInterfacedObject.Create;
  I := (O as IInterface);
  FIInterfaceList.Add(I);
  CheckEquals(1,FIInterfaceList.Count);
  CheckEquals(2,O.RefCount);
end;

procedure TestIInterfaceList.TestInsert;
var
  I1 : IInterface;
begin
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  I1 := TInterfacedObject.Create;
  FIInterfaceList.Insert(1,I1);
  CheckEquals(5,FIInterfaceList.Count);
  CheckEquals(1,FIInterfaceList.IndexOf(I1));
end;

procedure TestIInterfaceList.TestLast;
var
  ReturnValue: IInterface;
  I1 : IInterface;
begin
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  I1 := TInterfacedObject.Create;
  FIInterfaceList.Add(I1);
  ReturnValue := FIInterfaceList.Last;
  CheckSame(I1,ReturnValue);
end;

procedure TestIInterfaceList.TestRemove;
var
  ReturnValue: Integer;
  I1 : IInterface;
  O  : TInterfacedObject;
begin
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  O := TInterfacedObject.Create;
  I1 := (O as IINterface);
  FIInterfaceList.Add(I1); // 2
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  ReturnValue := FIInterfaceList.Remove(I1);
  CheckEquals(2,ReturnValue);
  CheckEquals(-1,FIInterfaceList.IndexOf(I1));
  CheckEquals(1,O.RefCount);
end;

procedure TestIInterfaceList.TestGetEnumerator;
var
  cnt : Integer;
  Item : IInterface;
begin
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  FIInterfaceList.Add(TInterfacedObject.Create);
  cnt := 0;
  for Item in FIInterfaceList do
  begin
    checkEquals(cnt,FIInterfaceList.IndexOf(Item),'EnumTest');
    Inc(cnt);
  end;
  CheckEquals(4,Cnt);
end;


initialization
  // Register any test cases with the test runner
  RegisterTest(TestTThreadList.Suite);
  RegisterTest(TestIInterfaceList.Suite);
end.

