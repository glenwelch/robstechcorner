unit TestRttiUtils;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, TypInfo, Classes, RTTI, RttiUtils, SysUtils,Generics.Collections;

//uses
///  TestFramework, SysUtils, TypInfo, Classes, Rtti, RttiUtils, Generics.Collections;

type
  // Test methods for class TEnumerableFactory

  TestTEnumerableFactory = class(TTestCase)
  strict private
  public
  published
//    procedure TestCreateRTTIEnumExpanded;
//    procedure TestGenListInt;
//    procedure TEstGenListIntSupported;
    procedure TestInvokeTListIntEnum;
  end;

implementation




//procedure TestTEnumerableFactory.TestCreateRTTIEnumExpanded;
//// Argh...      In TestGenListInt, it fails with Invalid Type Cast when calling
//// TEnumerableFactory.CreateRttiEnum(LV)
//// The code of that mehod is inline here to see if I can narrow it down.
//var
// C : TRttiContext;
// lEnumMethod : TRttiMethod;
// lEnumerator : TValue;
// lMoveNext : TRttiMethod;
// lCurrent : TRttiProperty;
// T : TRttiType;
// L : TList<Integer>;
// LV : TValue;
//begin
// L := TList<Integer>.Create;
// L.Add(1);
// L.Add(2);
// C := TRttiContext.Create;
// LV := L;
//
//
// T := C.GetType(LV.TypeInfo);
// lEnumMethod := T.GetMethod('GetEnumerator');
//// if Not Assigned(lGetEnum) then
////    raise EEnumerableFactoryException.CreateFmt('No Enumerator Adapter avalable for Value Specified: %s',[aValue.TypeInfo.Name]);
// lEnumerator := lEnumMethod.Invoke(LV,[]);
//
// lMoveNext := C.GetType(lEnumerator.TypeInfo).GetMethod('MoveNext');
// lCurrent := C.GetType(lEnumerator.TypeInfo).GetProperty('Current');
//
// if Not Assigned(lMoveNext) then
//    raise EEnumerableFactoryException.CreateFmt('GetEnumerator did not return a method named MoveNext',[LV.TypeInfo.Name]);
//
// if Not Assigned(lCurrent) then
//    raise EEnumerableFactoryException.CreateFmt('GetEnumerator did not return a property named Current',[LV.TypeInfo.Name]);
//
//// result := TRttiEnumerator.Create(lEnumerator.AsObject,lContext,lCurrent,lMoveNext);
//end;


procedure TestTEnumerableFactory.TestInvokeTListIntEnum;
var
 L : TList<Integer>;
 L2 : TLIst<Integer>;
 C : TRttiContext;
 T : TRttiType;
 LV : TValue;

 lEnumMethod : TRttiMethod;
 lType : TRttiType;
 lEnumerator : TValue;
 lEnumType : TRttiType;
 lMoveNextMethod : TRttiMethod;
 lCurrentProp : TRttiProperty;
 ValuePtr : Pointer;

begin
 L := TList<Integer>.Create;
// L2 := TList<Integer>.Create;
 try
 L.Add(1);
 L.Add(2);
 C := TRttiContext.Create;
{$REGION 'BLAH'}
// T :=  C.GetType(L.ClassInfo);
// lEnumerator := T.GetMethod('GetEnumerator').Invoke(L,[]);
//
// lEnumType :=  C.GetType(lEnumerator.TypeInfo);
// lMoveNextMethod := lEnumType.GetMethod('MoveNext');
// lCurrentProp := lEnumType.GetProperty('Current');
//
// Check(Assigned(LMoveNextMethod),'MoveNext method not found');
// Check(Assigned(lCurrentProp),'Current property not found');
//
// while lMoveNextMethod.Invoke(lEnumerator.AsObject,[]).asBoolean do
// begin
//   L2.Add(lCurrentProp.GetValue(lEnumerator.AsObject).AsOrdinal);
// end;
//
// CheckEquals(L.Count,L2.Count);
// CheckEquals(1,L2.Items[0]);
// CheckEquals(2,L2.Items[1]);
{$ENDREGION}

 LV := L;
// L2.Clear;

 T :=  C.GetType(LV.TypeInfo);
 lEnumMethod := T.GetMethod('GetEnumerator');
 lEnumerator := lEnumMethod.Invoke(LV,[]);

 lEnumType :=  C.GetType(lEnumerator.TypeInfo);
 lMoveNextMethod := lEnumType.GetMethod('MoveNext');
 lCurrentProp := lEnumType.GetProperty('Current');

 Check(Assigned(LMoveNextMethod),'MoveNext method not found');
 Check(Assigned(lCurrentProp),'Current property not found');

// while lMoveNextMethod.Invoke(lEnumerator.AsObject,[]).asBoolean do
// begin
//   L2.Add(lCurrentProp.GetValue(lEnumerator.AsObject).AsOrdinal);
// end;

// CheckEquals(L.Count,L2.Count);
// CheckEquals(1,L2.Items[0]);
// CheckEquals(2,L2.Items[1]);


 finally
   L.Free;
   L2.Free;
 end;



end;


//procedure TestTEnumerableFactory.TestGenListInt;
//var
// L : TList<Integer>;
// LV : TValue;
// F : TEnumerableFactory;
// IVal : TValue;
// I : Integer;
//begin
// L := TList<Integer>.Create;
// L.Add(1);
// L.Add(2);
// LV := L;
// F := TEnumerableFactory.Create(LV);
// F.CreateRttiEnum(LV);
//
// I := 0;
// for IVal in F do
// begin
//   I := I + IVal.AsOrdinal;
// end;
// CheckEquals(3,I);
//
//
//end;
//
//procedure TestTEnumerableFactory.TEstGenListIntSupported;
//var
// L : TList<Integer>;
// C : TRttiContext;
//begin
// L := TList<Integer>.Create;
// C := TRttiContext.Create;
// CheckTrue(TEnumerableFactory.IsTypeSupported(C.GetType(L.ClassInfo)));
// L.Free;
//
//end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTEnumerableFactory.Suite);
end.

